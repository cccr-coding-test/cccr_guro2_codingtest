# 최적 부분 구조(Optimal Substructure)
#   - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다
# 중복되는 부분 문제(Overlapping Subproblem)
#   - 동일한 작은 문제를 반복적으로 해결해야 한다.

# 보텀업 방식: 상향식 - DP 테이블(결과 저장용 리스트)
# 탑다운 방식: 하향식 - memoization(한 번 게산한 결과를 메모리 공간에 메모하는 기법)

# 최적 부분 구조와 중복되는 부분 문제를 만족 -> 그리디보다 DP 이용


x = int(input())

# DP 테이블 초기화
d = [0] * (x+1)
# DP - bottom-up 방식
for i in range(2, x+1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i-1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i%2==0:
        d[i] = min(d[i], d[i//2]+1)
    # 3으로 나누어 떨어지는 경우
    if i%3==0:
        d[i] = min(d[i], d[i//3]+1)    
    # 5로 나누어 떨어지는 경우
    if i%5==0:
        d[i] = min(d[i], d[i//5]+1)
        
print(d[x])